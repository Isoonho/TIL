# chapter8. 인터페이스

## 8-1. 인터페이스의 역할

- 인터페이스(interface)는 **객체의 사용 방법을 정의한 타입**이다. 
- 인터페이스는 객체의 교환성을 높여주기 때문에 **다형성을 구현하는 매우 중요한 역할**을 한다. 
- 인터페이스는 개발 코드와 객체가 서로 통신하는 **접점 역할**을 한다. <img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120105154237.png" alt="image-20200120105154237" style="zoom:80%;" />

- 개발 코드는 객체의 내부 구조를 알 필요가 없고, **인터페이스의 메소드만** 알고 있으면 된다. 

- #### 인터페이스의 역할

  - 개발 코드를 수정하지 않고, 사용하는 객체를 변경할 수 있도록 하기 위해서
  - 개발 코드 변경 없이 리턴값 또는 실행 내용이 다양해 질 수 있다.(**다형성**)

<img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120105446488.png" alt="image-20200120105446488" style="zoom:80%;" />



<br>

## 8-2. 인터페이스 선언

- 인터페이스는 "~.java" 형태의 소스 파일로 작성되고 컴파일러(javac.exe)를 통해 "~.class" 형태로 컴파일되기 때문에 물리적 형태는 클래스와 동일하다. 

<br>

### 8-2-1. 인터페이스 선언

- 인터페이스 선언은 class 키워드 대신에 **interface 키워드를 사용**한다.

  > **[public] interface 인터페이스명 {...}**

- 인터페이스 이름은 클래스 이름을 작성하는 방법과 동일하다.
  - 영어 대소문자를 구분하며,
  - 첫 문자를 대문자로 하고 나머지는 소문자로 작성하는 것이 관례이다. 
- 클래스는 필드, 생성자, 메소드를 구성 멤버로 가지는데 비해, 인터페이스는 **상수와 메소드**만을 구성 멤버로 갖는다. 인터페이스는 객체로 생성할 수 없기 때문에 **생성자를 가질 수 없다.**

<img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120105955375.png" alt="image-20200120105955375" style="zoom:50%;" />

<br>

### 8-2-2. 상수 필드 선언(Constant Field)

- 인터페이스는 데이터를 저장할 수 없기 때문에 데이터를 저장할 인스턴스 또는 정적 필드를 선언할 수 없지만, **상수 필드**는 선언할 수 있다.
- 상수는 "**public static final**" 로 선언한다. 따라서 인터페이스에 선언된 필드는 모두 public static final의 특성을 갖는다. (public, static, final 생략시 컴파일 과정에서 자동으로 붙음)
- 상수명은 **대문자로** 작성하되, 서로 다른 단어는 **언더바로 연결**하는 것이 관례이다.
- 인터페이스 상수는 static{} 블록으로 초기화할 수 없기 때문에, 반드시 **선언과 동시에 초기값을 지정**해야 한다.

<br>

### 8-2-3. 추상 메소드 선언(Abstract Method)

- 인터페이스를 통해 호출된 메소드는 **최종적으로 객체에서 실행**된다. 그렇기 때문에 인터페잇의 메소드는 실행 블록이 필요 없는 **추상 메소드로 선언**한다.
- 추상 메소드는 **리턴 타입, 메소드명, 매개 변수만 기술**되고 중괄호 {}를 붙이지 않는 메소드를 말한다. 
- 인터페이스에 선언된 추상 메소드는 모두 "**public abstract**"의 특성을 갖기 때문에 public abstract를 생략하더라도 자동적으로 컴파일 과정에서 붙게 된다. 

<img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120111017527.png" alt="image-20200120111017527" style="zoom:80%;" />

<br>

### 8-2-4. 디폴트 메소드 선언

- 형태는 클래스의 인스턴스 메소드와 동일한데, **default 키워드**가 리턴 타입 앞에 붙는다.
- 디폴트 메소드는 public 특성을 갖기 때문에 public을 생략하더라도 자동적으로 컴파일 과정에서 붙게 된다.

> **[public] default 리턴타입 메소드명(매개 변수, ...){...}**

<br>

### 8-2-5. 정적 메소드 선언

- 형태는 **클래스의 정적 메소드와 완전 동일**하다.
- 정적 메소드는 public 특성을 갖기 때문에 public을 생략하더라도 자동적으로 컴파일 과정에서 붙게 된다. 

> **[public] static 리턴타입 메소드명(매개 변수, ...){...}**

<br>

## 8-3. 인터페이스 구현

- 개발 코드가 인터페이스 메소드를 호출하면 인터페이스는 객체의 메소드를 호출한다. 
- 객체는 인터페이스에서 정의된 **추상 메소드와 동일한 메소드 이름, 매개 타입, 리턴 타입을 가진 실체 메소드를 가지고 있어야 한다.**
- 이러한 객체를 인터페이스의 구현(implement) 객체라고 하고, 구현 객체를 생성하는 클래스를 구현 클래스라고 한다. 

<img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120113823471.png" alt="image-20200120113823471" style="zoom:80%;" />

<br>

### 8-3-1. 구현 클래스

- 구현 클래스는 보통의 클래스와 동일한데, 인터페이스 타입으로 사용할 수 있음을 알려주기 위해 클래스 선언부에 **implements 키워드를 추가하고 인터페이스명을 명시**해야 한다.

<img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120114048963.png" alt="image-20200120114048963" style="zoom:50%;" />

- 그리고 **인터페이스에 선언된 추상 메소드의 실체 메소드를 선언**해야 한다. 

- 구현 클래스에서 인터페이스의 추상 메소드들에 대한 실체 메소드를 작성할 때 주의할 점은 인터페이스의 모든 메소드는 기본적으로 public 접근 제한을 갖기 때문에 **public 보다 더 낮은 접근 제한으로 작성할 수 없다.**

- 만약 인터페이스에 선언된 추상 메소드에 대응하는 실체 메소드를 구현 클래스가 작성하지 않으면, **구현 클래스는 자동적으로 추상 클래스가 된다.** 그렇기 때문에 클래스 선언부에 abstract 키워드를 추가해야한다.

  ```java
  public abstract class Television implements RemoteControl{
    public void turnOn(){...}
    public void turnOff(){...}
  }
  ```



- 구현 클래스가 작성되면 new 연산자로 객체를 생성할 수 있다. 문제는 어떤 타입의 변수에 대입하느냐이다.

- 다음과 같이 Television 객체를 생성하고 Television 변수에 대입한다고 인터페이스를 사용하는 것이 아니다.

  ```java
  Television tv = new Television();
  ```

- 인터페이스로 구현 객체를 사용하려면 다음과 같이 **인터페이스 변수를 선언하고 구현 객체를 대입**해야 한다.

- 인터페이스 변수는 **참조 타입**이기 때문에 구현 객체가 대입될 경우 **구현 객체의 번지를 저장**한다.

  > 인터페이스 변수;
  >
  > 변수 = 구현객체;
  >
  > or
  >
  > 인터페이스 변수 = 구현객체;

<br>

### 8-3-2. 익명 구현 객체

- 구현 클래스를 만들어 사용하는 것이 일반적이고, 클래스를 재사용할 수 있기 때문에 편리하지만, 일회성의 구현 객체를 만들기 위해 소스 파일을 만들고 클래스를 선언하는 것은 비효율적이다. 

- 자바는 **소스 파일을 만들지 않고도 구현 객체를 만들 수 있는 방법**을 제공하는데, 그것이 익명 구현 객체이다.

- UI 프로그래밍에서 이벤트를 처리하기 위해, 그리고 임시 작업 스레드를 만들기 위해 익명 구현 객체를 많이 활용한다. 

- 다음은 익명 구현 객체를 생성해서 인터페이스 변수에 대입하는 코드이다. 작성 시 주의할 점은 하나의 실행문이므로 끝에는 **세미콜론(;)을 반드시 붙여야 한다.**

  > 인터페이스 변수 = new 인터페이스(){
  >
  > ​	// 인터페이스에 선언된 추상 메소드의 실체 메소드 선언
  >
  > };

- new 연산자 뒤에는 클래스 이름이 와야 하는데, 이름이 없다. 인터페이스( ){ }는 인터페이스를 구현해서 중괄호 { }와 같이 클래스를 선언하라는 뜻이고, **new 연산자는 이렇게 선언된 클래스를 객체로 생성**한다.
- 중괄호 { }에는 인터페이스에 선언된 모든 추상 메소드들의 **실체 메소드를 작성**해야 한다.
- 추가적으로 필드와 메소드를 선언할 수 있지만, 익명 객체 안에서만 사용할 수 있고 인터페이스 변수로 접근할 수 없다. 

<br>

### 8-3-3. 다중 인터페이스 구현 클래스

- 객체는 다음 그림과 같이 다수의 인터페이스 타입으로 사용할 수 있다.

<img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120124017602.png" alt="image-20200120124017602" style="zoom:70%;" />

- 인터페이스 A와 인터페이스 B가 객체의 메소드를 호출할 수 있으려면 객체는 이 두 인터페이스를 모두 구현해야 한다. 

  <img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120124101037.png" alt="image-20200120124101037" style="zoom:70%;" />

- 다중 인터페이스를 구현할 경우, 구현 클래스는 모든 인터페이스의 추상 메소드에 대해 **실체 메소드를 작성**해야 한다. 만약 하나라도 없으면 추상 클래스로 선언해야 한다. 

<br>

## 8-4. 인터페이스 사용

- 인터페이스로 구현 객체를 사용하려면 다음과 같이 인터페이스 변수를 선언하고 구현 객체를 대입해야 한다.
- 인터페이스 변수는 **참조 타입**이기 때문에 구현 객체가 대입될 경우 **구현 객체의 번지**를 저장한다.

![image-20200120141032674](/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120141032674.png)

- 예를 들어 RemoteControl 인터페이스로 구현 객체인 Television과 Audio를 사용하려면 다음과 같이 RemoteControl 타입 변수 rc를 선언하고 구현 객체를 대입해야 한다.

![image-20200120141126675](/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120141126675.png)

- 개발 코드에서 인터페이스는 클래스의 필드, 생성자 또는 메소드의 매개 변수, 생성자 또는 메소드의 로컬 변수로 선언될 수 있다.

<br>

### 8-4-1. 추상 메소드 사용

- 구현 객체가 인터페이스 타입에 대입되면 인터페이스에 선언된 추상 메소드를 개발 코드에서 호출 할 수 있게 된다. 
- 개발 코드에서 RemoteControl의 변수 rc로 turnOn() 또는 turnOff() 메소드를 호출하면 구현 객체의 turnOn()과 turnOff() 메소드가 자동 실행된다.

<img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120141429476.png" alt="image-20200120141429476" style="zoom:50%;" />

<br>

### 8-4-2. 디폴트 메소드 사용

- **디폴트 메소드는 인터페이스에 선언되지만, 인터페이스에서 바로 사용할 수 없다.** 

- 디폴트 메소드는 추상 메소드가 아닌 인스턴스 메소드이므로 구현 객체가 있어야 사용할 수 있다. 

- 예를 들어 RemoteControl 인터페이스 setMute()라는 디폴트 메소드를 가지고 있지만, 이 메소드를 다음과 같이 호출할 수는 없다.

  ```java
  RemoteControl.setMute(true);
  ```

- setMute( ) 메소드를 호출하려면 RemoteControl의 구현 객체가 필요한데, 다음과 같이 Television 객체를 인터페이스 변수에 대입하고 나서 setMute( )를 호출할 수 있다. 

  - 비록 setMute( )가 Television에 선언되지는 않았지만 Television 객체가 없다면 setMute( )도 호출할 수 없다.

  ```java
  RemoteControl rc = new Television();
  rc.setMute(true);
  ```



- 디폴트 메소드는 인터페이스의 모든 구현 객체가 가지고 있는 기본 메소드라고 생각하면 된다. 그러나 어떤 구현 객체는 디폴트 메소드의 내용이 맞지 않아 수정이 필요할 수도 있다. 
- 구현 클래스를 작성할 때 디폴트 메소드를 재정의(오버라이딩)해서 자신에게 맞게 수정하면 디폴트 메소드가 호출될 때 자신을 재정의한 메소드가 호출된다. 

<br>

### 8-4-3. 정적 메소드 사용

- 인터페이스의 정적 메소드는 인터페이스로 바로 호출이 가능하다. 

<br>

## 8-5. 타입 변환과 다형성

- 인터페이스도 다형성을 구현하는 기술이 사용된다.  오히려 요즘은 상속보다는 인터페이스를 통해서 다형성을 구현하는 경우가 더 많다. 
- **다형성**은 하나의 타입에 대입되는 객체에 따라서 **실행 결과가 다양한 형태**로 나오는 성질을 말한다. 
- 부모 타입에 어떤 자식 객체를 대입하느냐에 따라 실행 결과가 달라지듯이, 인터페이스 타입에 어떤 구현 객체를 대입하느냐에 따라 실행 결과가 달라진다. 
- 상속은 같은 종류의 하위 클래스를 만드는 기술이고, 인터페이스는 **사용 방법이 동일한 클래스를 만드는 기술**이라는 개념적 차이는 있지만, 둘 다 다형성을 구현하는 기술임에는 틀림없다. 
- 프로그램을 개발할 때 인터페이스를 사용해서 메소드를 호출하도록 코딩을 했다면, **구현 객체를 교체하는 것은 매우 손쉽고 빠르게** 할 수 있다.  
- 프로그램 소스 코드는 변함이 없는데, 구현 객체를 교체함으로써 프로그램의 실행 결과가 다양해진다. 이것이 인터페이스의 다형성이다. 

<br>

### 8-5-1. 자동 타입 변환(Promotion)

- 구현 객체가 인터페이스 타입으로 변환되는 것은 자동 타입 변환(Promotion)에 해당한다. 

<img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120164043783.png" alt="image-20200120164043783" style="zoom:67%;" />

- 인터페이스 구현 클래스를 상속해서 자식 클래스를 만들었다면 **자식 객체 역시 인터페이스 타입으로 자동 타입 변환**시킬 수 있다.<img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120164143458.png" alt="image-20200120164143458" style="zoom:67%;" />

- 자동 타입 변환을 이용하면 **필드의 다형성**과 **매개 변수의 다형성을 구현**할 수 있다. 
- 필드와 매개 변수의 타입을 인터페이스로 선언하면 여기에 다양한 구현 객체를 대입해서 실행 결과를 다양하게 만들 수 있다.

<br>

### 8-5-2. 필드의 다형성

- 다음 그림은 상속에서 다형성을 설명할 때 보여준 그림과 유사하다. 
- 한국 타이어와 금호 타이어는 공통적으로 타이어 인터페이스를 구현했기 때문에 모두 타이어 인터페이스에 있는 메소드를 가지고 있다. 따라서 타이어 인터페이스로 동일하게 사용할 수 있는 **교체 가능한 객체**에 해당한다. 

<img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120164628796.png" alt="image-20200120164628796" style="zoom:150%;" />

- 자동차를 설계할 때 다음과 같이 필드 타입으로 타이어 인터페이스를 선언하게 되면 필드값으로 한국 타이어 또는 금호 타이어 객체를 대입할 수 있다. 

<img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120164735105.png" alt="image-20200120164735105" style="zoom:80%;" />

- Car 객체를 생성한 후, 초기값으로 대입한 구현 객체 대신 다른 구현 객체를 대입할 수도 있다. 이것이 타이어 교체에 해당한다. 

<img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120164835557.png" alt="image-20200120164835557" style="zoom:70%;" />

- frontLeftTire와 frontRightTire에 어떠한 타이어 구현 객체가 저장되어도 Car 객체는 타이어 인터페이스에 선언된 메소드만 사용하므로 전혀 문제가 되지 않는다. 다음은 run( ) 메소드에서 타이어 인터페이스에 선언된 roll( ) 메소드를 호출한다.

<img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120164952560.png" alt="image-20200120164952560" style="zoom:70%;" />

- frontLeftTire와 frontRightTire를 교체하기 전에는 HankookTire 객체의 roll( ) 메소드가 호출되지만, KumhoTire로 교체된 후에는 KumhoTire 객체의 roll( ) 메소드가 호출된다. 
  - **Car의 run( ) 메소드 수정 없이도 다양한 roll( ) 메소드의 실행 결과를 얻을 수 있게 되는 것이다.**

<br>

### 8-5-3. 인터페이스 배열로 구현 객체 관리

- 다음과 같이 **인터페이스 배열**로 관리할 수도 있다.

<img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120165536278.png" alt="image-20200120165536278" style="zoom:80%;" />

- 오른쪽 그림 처럼 인덱스로 표한할 수 있기 때문에 **대입이나 제어문에서 활용하기 매우 쉽다.**
- tires 배열의 각 항목은 Tire 인터페이스 타입이므로, 구현 객체인 KumhoTire를 대입하면 자동 타입 변환이 발생하기 때문에 아무런 문제가 없다. 구현 객체들을 배열로 관리하면 제어문에서 가장 많이 혜택을 본다. 
- 예를 들어 전체 타이어의 roll( ) 메소드를 호출하는 Car 클래스의 run( ) 메소드는 다음과 같이 for문으로 작성할 수 있다.

<img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120165717446.png" alt="image-20200120165717446" style="zoom:70%;" />

<br>

### 8-5-4. 매개 변수의 다형성

- 자동 타입 변환은 필드의 값을 대입할 때에도 발생하지만, 주로 **메소드를 호출할 때 많이 발생**한다. 매개값을 다양화하기 위해서 상속에서는 매개 변수를 부모 타입으로 선언하고, 호출할 때에는 자식 객체를 대입했었다.
- 이번에는 **매개 변수를 인터페이스 타입으로 선언하고 호출할 때에는 구현 객체를 대입**한다. 



- 예를 들어 다음과 같이 Driver 클래스에는 drive( ) 메소드가 정의되어 있는데 Vehicle 타입의 매개 변수가 선언되어 있다.

  ```java
  public class Driver{
    public void drive(Vehicle vehicle){
      vehicle.run();
    }
  }
  ```

  - Vehicle을 다음과 같이 인터페이스 타입이라고 가정해보자.

  ```java
  public interface Vehicle{
    public void run();
  }
  ```

  - 만약 Bus가 구현 클래스라면 다음과 같이 Driver의 drive( ) 메소드를 호출할 때 Bus 객체를 생성해서 매개값으로 줄 수 있다. 

  ```java
  Driver driver = new Driver();
  Bus bus = new Bus();
  driver.drive(bus);  //자동 타입 변환 발생 Vehicle vehicle = bus;
  ```

  - drive( ) 메소드는 Vehicle 타입을 매개 변수로 선언했지만, Vehicle을 구현한 Bus 객체가 매개값으로 사용되면 자동 타입 변환이 발생한다. 

<br>

### 8-5-5. 강제 타입 변환(Casting)

- 구현 객체가 인터페이스 타입으로 자동 변환하면, **인터페이스에 선언된 메소드만 사용 가능하다는 제약 사항**이 따른다.
- 예를 들어 인터페이스에는 세 개의 메소드가 선언되어 있고, 클래스에는 다섯 개의 메소드가 선언되어 있다면, 인터페이스로 호출 가능한 메소드는 세 개뿐이다.
- 하지만 경우에 따라서는 구현 클래스에 선언된 필드와 메소드를 사용해야 할 경우도 발생한다. 
- 이때 강제 타입 변환을 해서 다시 구현 클래스 타입으로 변환한 다음, 구현 클래스의 필드와 메소드를 사용할 수 있다. 

<br>

### 8-5-6. 객체 타입 확인(instanceof)

- 강제 타입 변환은 구현 객체가 인터페이스 타입으로 변환되어 있는 상태에서 가능하다.  그러나 어떤 구현 객체가 변환되어 있는지 알 수 없는 상태에서 무작정 변환을 할 경우 ClassCastException이 발생할 수도 있다. 

- 예를 들어 다음과 같이 Taxi 객체가 인터페이스로 변환되어 있을 경우, Bus 타입으로 강제 타입 변환하면 구현 클래스 타입이 다르므로 ClassCastException이 발생한다. 

  ```java
  Vehicle vehicle = new Taxi();
  Bus bus = (Bus) vehicle;
  ```

<br>

## 8-6. 인터페이스 상속

- 인터페이스도 다른 인터페이스를 상속할 수 있다. 
- 인터페이스는 클래스와는 달리 **다중 상속을 허용**한다.

![image-20200120231432875](/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120231432875.png)

- 하위 인터페이스를 구현하는 클래스는 하위 인터페이스의 메소드뿐만 아니라, **상위 인터페이스의 모든 추상 메소드에 대한 실체 메소드를 가지고 있어야 한다.** 
- 그렇기 때문에 구현 클래스로부터 객체를 생성하고 나서 다음과 같이 하위 및 상위 인터페이스 타입으로 변환이 가능하다. 

<img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120231736588.png" alt="image-20200120231736588" style="zoom:80%;" />

- 하위 인터페이스로 타입 변환이 되면 상-하위 인터페이스에 선언된 모든 메소드를 사용할 수 있으나, 상위 인터페이스로 타입 변환되면 상위 인터페이스에 선언된 메소드만 사용 가능하고 하위 인터페이스에 선언된 메소드는 사용할 수 없다. 

- 해당 타입의 인터페이스에 선언된 메소드만 호출 가능

  <img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20200120232003459.png" alt="image-20200120232003459" style="zoom:80%;" />

<br>

## 8-7. 디폴트 메소드와 인터페이스 확장

- 디폴트 메소드는 인터페이스에 선언된 인스턴스 메소드이기 때문에 **구현 객체가 있어야 사용할 수 있다.**
- 디폴트 메소드는 모든 구현 객체에서 공유하는 기본 메소드처럼 보이지만, 사실은 인터페이스에서 디폴트 메소드를 허용한 다른 이유가 있다. 

<br>

### 8-7-1. 디폴트 메소드의 필요성

- 인터페이스에서 **디폴트 메소드를 허용한 이유**는 **기존 인터페이스를 확장해서 새로운 기능을 추가**하기 위해서이다.
- 기존 인터페이스의 이름과 추상 메소드의 변경 없이 디폴트 메소드만 추가할 수 있기 때문에 이전에 개발한 구현 클래스를 그대로 사용할 수 있으면서, 새롭게 개발하는 클래스는 디폴트 메소드를 활용할 수 있다. 

<br>

### 8-7-2. 디폴트 메소드가 있는 인터페이스 상속

- 인터페이스 간에도 상속이 있는데, 부모 인터페이스에 디폴트 메소드가 정의 되어 있을 경우, 자식 인터페이스에서 디폴트 메소드를 활용하는 방법은 다음 세가지가 있다.
  - 디폴트 메소드를 단순히 상속만 받는다. 
  - 디폴트 메소드를 재정의(Override)해서 실행 내용을 변경한다.
  - 디폴트 메소드를 추상 메소드로 재선언한다.







































































