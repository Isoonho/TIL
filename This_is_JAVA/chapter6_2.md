# chapter6 - 2

[TOC]

<br>

# 6-9. 인스턴스 멤버와 this

- **인스턴스 (instance) 멤버**란 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말하는데, 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부른다. 우리가 지금까지 작성한 모든 필드와 메소드는 인스턴스 멤버들이었다.

- 인스턴스 필드와 메소드는 객체에 소속된 멤버이기 때문에 **객체 없이는 사용할 수 없다.**

  ```java
  public class Car{
    //필드
    int gas;
    
    //메소드
    void setSpeed(int speed){...}
  }
  ```

  - gas 필드와 setSpeed() 메소드는 인스턴스 멤버이기 때문에 외부 클래스에서 사용하기 위해서는 우선 Car객체 (인스턴스)를 생성하고 참조 변수 myCar 또는 yourCar로 접근해야 한다.

  ```java
  Car myCar = new Car();
  myCar.gas = 10;
  myCar.setSpeed(60);
  
  Car yourCar = new Car();
  yourCar.gas = 20;
  yourCar.setSpeed(80);
  ```

  - 인스턴스 필드 gas는 객체마다 따로 존재하고, **인스턴스 메소드 setSpeed()는 객체마다 존재하지 않고 메소드 영역에 저장되고 공유된다.**

- 객체 외부에서 인스턴스 멤버에 접근하기 위해 참조 변수를 사용하는 것과 마찬가지로 객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있다.

- 객체는 자신을 " this "라고 한다.

<br>

# 6-10. 정적 멤버와 static

- 정적(static)은 '고정된'이란 의미를 가지고 있다. 
- **정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다.** 
- 이들을 각각 정적 필드, 정적 메소드라고 부른다. 정적 멤버는 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 소속된 멤버이기 때문에 클래스 멤버라고도 한다.

<br>

## 6-10-1. 정적 멤버 선언

- 정적 필드와 정적 메소드를 선언하는 방법은 필드와 메소드 선언 시 **static키워드를 추가적으로 붙이면 된다.**

- 정적 필드와 정적 메소드는 클래스에 고정된 멤버이므로 클래스 로더가 클래스(바이트 코드)를 로딩해서 메소드 메모리 영역에 적재할 때 **클래스별로 관리**된다. 따라서 클래스의 로딩이 끝나면 바로 사용할 수 있다. 

- 필드를 선언할 때 **객체마다 가지고 있어야 할 데이터라면 인스턴스 필드로 선언하고**, **객체마다 가지고 있을 필요성이 없는 공용적인 데이터라면 정적 필드로 선언**하는 것이 좋다. 

  ```java
  public class Calculator{
    String color; // 객체별로 색깔이 다르다면 색깔은 인스턴스 필드
    static double pi = 3.14159; //원의 넓이나 둘레를 구할 때 필요한 파이는 객체마다 가지고 있을 필요가 없는 변하지 않는 공용적인 데이터
  }
  ```

- 메소드의 경우, **인스턴스 필드를 이용해서 실행해야 한다면 인스턴스 메소드로 선언**하고, **인스턴스 필드를 이용하지 않는다면 정적 메소드로 선언한다.**

  ```java
  public class Calculator{
    String color;                  // 인스턴스 필드
    void setColor(String color){   // 인스턴스 메소드
      this.color = color;
    }
    static int plus(int x, int y){ // 정적 메소드
      return x + y;
    }
    static int minus(int x, int y){// 정적 메소드
      return x - y;
    }
  }
  ```

<br>

## 6-10-2. 정적 멤버 사용

- 클래스가 메모리로 로딩되면 정적 멤버를 바로 사용할 수 있는데, 클래스 이름과 함께 **도트(.) 연산자로 접근**한다.

  ```java
  클래스.필드;
  클래스.메소드(매개값, ...);
  ```

  <br>

  ```java
  public class Calculator{
    static double pi = 3.14159;
    
    static int plus(int x, int y){...}
    static int minus(int x, int y){...}
  }
  ```

  ```java
  double result1 = 10 * 10 * Calculator.pi;
  int result2 = Calculator.plus(10, 5);
  int result3 = Calculator.minus(10, 5);
  ```

  - 정적 필드와 정적 메소드는 **원칙적으로는 클래스 이름으로 접근**해야 하지만 다음과 같이 **객체 참조 변수로도 접근이 가능**하다.

  ```java
  Calculator myCalc = new Calculator();
  double result1 = 10 * 10 * myCalc.pi;
  int result2 = myCalc.plus(10, 5);
  int result3 = myCalc.minus(10, 5);
  ```

  - 하지만 정적 요소는 **클래스 이름으로 접근하는 것이 좋다.**

<br>

## 6-10-3. 정적 초기화 블록

- 정적 필드는 다음과 같이 **필드 선언과 동시에 초기값을 주는 것이 보통이다.**

  ```java
  static double pi = 3.14159;
  ```

- 그러나 계산이 필요한 초기화 작업이 있을 수 있다. 

  - **인스턴스 필드는 생성자에서 초기화**하지만, **정적 필드는 객체 생성 없이도 사용해야 하므로 생성자에서 초기화 작업을 할 수 없다.** 생성자는 객체 생성 시에만 실행되기 때문이다. 

- 정적 필드의 복잡한 초기화 작업을 위해서 **정적 블록(static block)을 제공한다.**
- 정적 블록은 클래스가 메모리로 로딩될 때 자동적으로 실행된다. 정적 블록은 클래스 내부에 여러개가 선언되어도 상관없다. 

<br>

## 6-10-4. 정적 메소드와 블록 선언 시 주의할 점

- **이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다.** 또한 객체 자신의 참조인 this 키워드도 사용이 불가능하다.

- 정적 메소드와 정적 블록에서 인스턴스 멤버를 사용하고 싶다면 다음과 같이 객체를 먼저 생성하고 참조 변수로 접근해야 한다.

  ```java
  static void Method3(){
    ClassName obj = new ClassName();
    obj.field1 = 10;
    obj.method1();
  }
  ```

  - **main( ) 메소드도 동일한 규칙이 적용된다.** main( ) 메소드도 정적 메소드이므로 객체 생성 없이 인스턴스 필드와 인스턴스 메소드를 main( ) 메소드에서 바로 사용할 수 없다. 

<br>

## 6-10-5. 싱글톤(singleton)

- 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있는데, 단 하나만 생성된다고 해서 이 객체를 싱글톤이라고 한다. 

- 싱글톤을 만들려면 **클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야한다.** 

- 외부에서 생성자 호출을 막기 위해 private 접근 제한자를 붙여줘야 한다. 

- 그리고 자신의 타입인 정적 필드를 하나 선언하고 자신의 객체를 생성해 초기화한다. 참고로 클래스 내부에서는 new 연산자로 생성자 호출이 가능하다. 

- 정적 필드도 private 접근 제한자를 붙여 외부에서 필드값을 변경하지 못하도록 막는다. 대신 외부에서 호출할 수 있는 정적 메소드인 getInstance()를 선언하고 정적 필드에서 참자하고 있는 자신의 객체를 리턴해준다.

  ```java
  public class 클래스{
    //정적 필드
    pivate static 클래스 singleton = new 클래스();
    
    //생성자
    private 클래스(){}
    
    //정적 메소드
    static 클래스 getInstance(){
      return singleton;
    }
  }
  ```

  - 외부에서 객체를 얻는 유일한 방법은 getInstance( ) 메소드를 호출하는 방법이다. getInstance( ) 메소드는 단 하나의 객체만 리턴하기 때문에 아래 코드에서 변수1과 변수2는 동일한 객체를 참조한다.

  ```java
  클래스 변수1 = 클래스.getInstance();
  클래스 변수2 = 클래스.getInstance();
  ```

  <br>

# 6-11. final 필드와 상수

## 6-11-1. final 필드

- final의 의미는 **최종이란 뜻**을 가지고 있다.

- final 필드는 **초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없다**는 것이다.

  ```java
  final 타입 필드 [= 초기값];
  ```

- final 필드의 초기값을 줄 수 있는 방법은 딱 두가지 밖에 없다.

  - 첫 번째는 **필드 선언 시**에 주는 방법이고,
  - 두 번째는 **생성자에서** 주는 방법이다.

- 단순 값이라면 필드 선언 시에 주는 것이 제일 간단하다.

- 하지만 복잡한 초기화 코드가 필요하거나 객체 생성 시에 외부 데이터로 초기화해야 한다면 생성자에서 초기값을 지정해야 한다. 

<br>

## 6-11-2. 상수(static final)

- **일반적으로 불변의 값을 상수라고 부른다.** 불변의 값은 수학에서 사용되는 원주율 파이, 지구의 무게 및 둘레등이 해당된다. 

- 이런 **불변의 값을 저장하는 필드를 자바에서는 상수(constant)라고 한다.**

- final 필드를 상수라고 부르진 않는다. 왜냐하면 불변의 값은 객체마다 저장할 필요가 없는 공용성을 띄고 있으며, 여러 가지 값으로 초기화될 수 없기 때문이다. 

  - final 필드는 객체마다 저장되고, 생성자의 매개값을 통해서 여러 가지 값을 가질 수 있기 때문에 상수가 될 수 없다. 

- **상수는 static이면서 final 이어야 한다.** static final 필드는 객체마다 저장되지 않고, 클래스에만 포함된다.

  ```java
  static fianl 타입 상수 [= 초기값];
  ```

  - 초기값이 단순 값이라면 선언 시에 주는 것이 일반적이지만, **복잡한 초기화일 경우 정적 블록에서**도 할 수 있다.

  ```java
  static final 타입 상수;
  static{
    상수 = 초기값;
  }
  ```

- **상수 이름은 모두 대문자로 작성하는 것이 관례이다.** 만약 서로 다른 단어가 혼합된 이름이라면 언더바로 단어들을 연결해준다. 

  ```java
  static final double PI = 3.14159;
  static final double EARTH_SURFATE_AREA;
  ```

<br>

# 6-12. 패키지

- 자바에서는 클래스를 체계적으로 관리하기 위해 패키지를 사용한다. 

- 우리가 폴더를 만들어 파일을 저장 관리하듯이 패키지를 만들어 클래스를 저장 관리한다. 

- 패키지는 단순히 파일 시스템의 폴더 기능만 하는 것이 아니라 **클래스의 일부분이다.** 

- 패키지는 클래스를 유일하게 만들어주는 **식별자 역할을 한다.** 클래스의 전체 이름은 "패키지명 + 클래스명"인데 패키지가 상-하위로 구분되어 있다면 도트를 사용해서 다음과 같이 표현한다.

  ```java
  상위패키지.하위패키지.클래스
  ```

<br>

## 6-12-1. 패키지 선언

- 패키지는 클래스를 컴파일하는 과정에서 자동적으로 생성되는 폴더이다. 컴파일러는 클래스에 포함되어 있는 패키지 선언을 보고, 파일 시스템의 폴더로 자동 생성시킨다. 

  ```java
  package 상위패키지.하위패키지;
  
  public class ClassName{...}
  ```

- 패키지 이름은 개발자가 임의대로 지어주면 되지만, **지켜야 할 몇 가지 규칙이 있다.**

  - 숫자로 시작해서는 안 되고, _ , $ 를 제외한 특수 문자를 사용해서는 안 된다.
  - java로 시작하는 패키지는 자바 표준 API에서만 사용하므로 사용해서는 안된다.
  - 모두 소문자로 작성하는 것이 관례이다. 

<br>

## 6-12-2. 패키지 선언이 포함된 클래스 컴파일

<br>

## 6-12-3. 이클립스에서 패키지 생성과 클래스 생성

<br>

## 6-12-4. import 문

- 같은 패키지에 속하는 클래스들은 아무런 조건 없이 다른 클래스를 사용할 수 있지만, 다른 패키지에 속하는 클래스를 사용하려면 두 가지 방법 중 하나를 선택해야 한다.

- **첫 번째 방법은 패키지와 클래스를 모두 기술하는 것이다.** 다음은 com.hankook 패키지에 소속된 Tire 클래스를 이용해서 필드를 선언하고 객체를 생성한 것이다.

  ```java
  package com.mycompany;
  
  public class Car{
    com.hankook.Tire tire = new com.hankook.Tire();
  }
  ```

  - 패키지 이름이 짧을 경우에는 불편함이 없겠지만, 패키지 이름이 길거나 이렇게 사용해야 할 클래스 수가 많다면 패키지 이름을 붙인다는 것은 전체 코드를 난잡해 보이게 할 수 있다.

- **그래서 두 번째 방법인 import문을 주로 사용한다.** 사용하고자 하는 패키지를 import문으로 선언하고, 클래스를 사용할 때에는 패키지를 생략하는 것이다.

  ```java
  package com.mycompany;
  
  import com.hankook.Tire;
  // 또는 import com.hankook.*;
  
  public class Car{
    Tire tire = new Tire();
  }
  ```

  - import 문이 작성되는 위치는 패키지 선언과 클래스 선언 사이다. 
  - ***은 패키지에 속하는 모든 클래스들을 의미한다.**
  - **주의할 점**은 import문으로 지정된 패키지의 하위 패키지는 import 대상이 아니다. 만약 하위 패키지에 있는 클래스들도 사용하고 싶다면 import문을 하나 더 작성해야 한다. 

- **패키지 이름 전체를 기술하는 첫 번째 방법이 꼭 필요한 경우가 있는데**, 서로 다른 패키지에 동일한 클래스 이름이 존재하고, 두 패키지가 모두 import 되어 있을 경우이다.

<br>

# 6-13. 접근 제한자

- 라이브러리 클래스를 설계할 때에는 외부 클래스에서 접근할 수 있는 멤버와 접근할 수 없는 멤버로 구분해서 필드, 생성자, 메소드를 설계하는 것이 바람직하다. 
- 객체 생성을 막기위해 생성자를 호출하지 못하게 하거나 객체의 특정 데이터를 보호하기 위해 해당 필드에 접근하지 못하도록 막아야 한다.
- 그리고 특정 메소드를 호출할 수 없도록 제한할 필요가 있다. 자바는 이러한 기능을 구현하기 위해 접근 제한자를 제공하고 있다. 
- 접근 제한자는 네 가지 종류가 있다.
  - public 접근 제한자 : **외부 클래스가 자유롭게 사용할 수 있는 공개 멤버를 만든다.**
  - protected 접근 제한자 : **같은 패키지 또는 자식 클래스에서 사용할 수 있는 멤버를 만든다.**
  - private 접근 제한자 : **외부에 노출되지 않는 멤버를 만든다.**
  - default 접근 제한자 : **같은 패키지에 소속된 클래스에서만 사용할 수 있는 멤버를 만든다. **





![image-20191224150548993](/Users/hwangsunho/Library/Application Support/typora-user-images/image-20191224150548993.png)

<br>

## 6-13-1. 클래스의 접근 제한

- 클래스를 선언할 때 고려해야 할 사항은 같은 패키지 내에서만 사용할 것인지, 아니면 다른 패키지에서도 사용할 수 있도록 할 것인지를 결정해야 한다. 

- **클래스에 적용할 수 있는 접근 제한은 public 과 default 단 두 가지인데,** 다음과 같은 형식으로 작성한다.

  ```java
  //default 접근 제한
  class 클래스{...}
  
  //public 접근 제한
  public class zmffotm {...}
  ```

### 1) default 접근 제한

- 클래스를 선언할 때 public 을 생략했다면 클래스는 default 접근 제한을 가진다. 
- 클래스가 default 접근 제한을 가지게 되면 **같은 패키지에서는 아무런 제한 없이 사용**할 수 있지만 **다른 패키지에서는 사용할 수 없도록 제한된다.**

<img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20191224155601214.png" alt="image-20191224155601214" style="zoom:80%;" />

### 2) public 접근 제한

- 클래스가 public 접근 제한을 가지게 되면 같은 패키지뿐만 아니라 **다른 패키지에서도 아무런 제한 없이 사용할 수 있다.**
- 클래스를 다른 개발자가 사용할 수 있도록 라이브러리 클래스로 개발되어야 한다면, 반드시 public 접근 제한을 갖도록 해야 한다. 

<img src="/Users/hwangsunho/Library/Application Support/typora-user-images/image-20191224155728115.png" style="zoom:80%;" />

<br>

## 6-13-2. 생성자의 접근 제한

- **객체를 생성하기 위해서는 new 연산자로 생성자를 호출해야 한다.**

- **생성자는 다음과 같이 public, protected, default, private 접근 제한을 가질 수 있다.**

  ```java
  public class ClassName{
    //public 접근 제한
    public ClassName(){}
    
    //protected 접근 제한
    protected ClassName(){}
    
    //default 접근 제한
    ClassName(){}
    
    //private 접근 제한
    private ClassName(){}
  }
  ```

- 클래스에 생성자를 선언하지 않으면 컴파일러에 의해 자동적으로 기본 생성자가 추가된다. 

- **자동으로 생성되는 기본 생성자의 접근 제한은 클래스의 접근 제한과 동일하다. 클래스가 default 접근 제한을 가지면 기본 생성자도 default 접근 제한을 가지고, 클래스가 public 접근 제한을 가지마녀 기본 생성자도 public 접근 제한을 가진다.**

<br>

## 6-13-3. 필드와 메소드의 접근 제한

- 필드와 메소드를 선언할 때 고려해야 할 사항은 클래스 내부에서만 사용할 것인지, 패키지 내에서만 사용할 것인지, 아니면 다른 패키지에서도 사용할 수 있도록 할 것인지를 결정해야 한다. 

- **필드와 메소드는 다음과 같이 public, protected, default, private 접근 제한을 가진다.**

  ```java
  //필드 선언
  [public | protected | private] [static] 타입 필드;
  
  //메소드 선언
  [public | protected | private] [static] 리턴 타입 메소드(){}
  ```

<br>

# 6-14. Getter와 Setter 메소드

- 일반적으로 객체 지향 프로그래밍에서 **객체의 데이터는 객체 외부에서 직접적으로 접근하는 것을 막는다.** 

- 그 이유는 객체의 데이터를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성(결점이 없는 성질)이 깨어질 수 있기 때문이다. 

- 예를 들어 자동차의 속도는 음수가 될 수 없는데, 외부에서 음수로 변경하면 객체의 무결성이 깨진다. 실제로 다음 코드는 Car객체의 speed 필드값을 -100으로 변경시킨다.

  ```java
  myCar.speed = -100;
  ```

  - 이러한 문제점을 해결하기 위해 객체 지향 프로그래밍에서는 **메소드를 통해서 데이터를 변경하는 방법을 선호한다.** 데이터는 외부에서 접근할 수 없도록 막고 메소드는 공개해서 외부에서 메소드를 통해 데이터에 접근하도록 유도한다. 
  - 그 이유는 메소드는 매개값을 검증해서 유효한 값만 데이터로 저장할 수 있기 때문이다.

- **이러한 역할을 하는 메소드가 Setter이다. ** 예를 들어 자동차의 속도를 setSpeed( ) 메소드로 변경할 경우 다음과 같이 검증 코드를 작성할 수 있다.

  ```java
  void setSpeed(double speed){
    if(speed<0){     //if문은 매개값이 음수일 경우 speed필드에 0으로 저장하고, 메소드 실행을 종료 시킨다.
      this.speed = 0;
      return;
    }else{
      this.speed = speed;
    }
  }
  ```

<br>

- 외부에서 객체의 데이터를 읽을 때도 메소드를 사용하는 것이 좋다. 

- **객체 외부에서 객체의 필드값을 사용하기에 부적절한 경우도 있다. ** 이런 경우에는 메소드로 필드값을 가공한 후 외부로 전달하면 된다. 

- **이런 메소드가 바로 Getter이다.** 예를 들어 자동차의 속도를 마일에서 KM 단위로 환산해서 외부로 리턴해주는 getSpeed() 메소드를 다음과 같이 작성할 수 있다.

  ```java
  double getSpeed(){       //필드값인 마일을 km 단위로 환산 후 외부로 리턴
    double km = speed*1.6;
    return km;
  }
  ```

<br>

- 클래스를 선언할 때 가능하다면 필드를 private로 선언해서 외부로부터 보호하고, 필드에 대한 Setter와 Getter메소드를 작성해서 필드값을 안전하게 변경/사용하는 것이 좋다.

- 다음은 Setter와 Getter 메소드를 선언하는 방법을 보여준다. 검증 코드나 변환 코드는 필요에 따라 추가해야 한다.

  ```java
  private 타입 fieldName;
  
  //Getter
  public 리턴 타입 getFieldName(){
    return fieldName;
  }
  
  //Setter
  public void setFieldName(타입 fieldName){
    this.fieldName = fieldName;
  }
  ```

- **필드 타입이 boolean일 경우에는 Getter는 get으로 시작하지 않고 is로 시작하는 것이 관례이다.** 예를 들어 stop 필드의 Getter와 Setter는 다음과 같이 작성할 수 있다. 

  ```java
  private boolean stop;
  
  //Getter
  public boolean isStop(){
    return stop;
  }
  
  //Setter
  public void setStop(boolean stop){
    this.stop = stop;
  }
  ```

<br>

- 만약 외부에서 필드값을 읽을 수만 있고 변경하지 못하도록 하려면**(읽기 전용)** Getter 메소드만 선언해도 좋고, 아니면 Setter 메소드를 private 접근 제한을 갖도록 선언해도 좋다.



























































