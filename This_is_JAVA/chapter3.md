# Chapter3. 연산자

## 3-1. 연산자와 연산식

- 프로그램에서 데이터를 처리하여 결과를 산출하는 것을 연산(operation)이라고 한다. **연산에 사용되는 표시나 기호를 연산자(operator)**라고 하고, **연산되는 데이터는 피연산자(operand)**라고 한다. 연산자와 피연산자를 이용하여 연산의 과정을 기술한 것을 연산식(expressions)이라고 부른다. 예를 들어 연산식에서 +, -, *, ==은 연산자이고 x, y, z변수는 피연산자이다.

  ```java
  x + y
  x - y
  x * y + z
  x == y
  ```

- 산술 연산자일 경우는 숫자 타입(byte, short, int, long, float, double)으로 결과값이 나오고, 비교 연산자와 논리 연산자는 논리(boolean)타입으로 나온다. 

- 연산자는 필요로 하는 피연산자의 수에 따라 단항, 이항, 삼항 연산자로 구분된다. 

  ```java
  단항 연산자 : ++x;
  이항 연산자 : x + y;
  삼항 연산자 : (sum>90) ? "A" : "B";
  ```

- 연산식은 반드시 하나의 값을 산출한다. 그렇기 때문에 하나의 값이 올 수 있는 곳이면 어디든지 값 대신에 연산식을 사용할 수 있다. 

- 연산식은 다른 연산식의 피연산자 위치에도 올 수 있다. 

  ```java
  boolean result = (x+Y) < 5;
  ```



## 3-2. 연산의 방향과 우선순위

- 연산식에는 다양한 연산자가 복합적으로 구성된 경우가 많다. 예를 들어 다음과 같은 연산식에서 && 연산자가 먼저 처리될까 아니면 >, < 연산자가 먼저 처리될까?

  ```java
  x>0 && y<0;
  ```

- 프로그램에서는 연산자의 연산 방향과 연산자 간의 우선순위가 정해져 있다. &&보다는 >, <가 우선순위가 높다. 그러면 우선순위가 같은 연산자들끼리는 어떤 순서로 처리가 될까? 이 경우에는 연산의 방향에 따라 달라진다. 대부분의 연산자는 왼쪽에서부터 오른쪽으로(—>) 연산을 시작한다. 

  ```java
  100 * 2 / 3 % 5
  ```

- 하지만 **단항 연산자(++, - -, ~, !), 부호 연산자(+, -), 대입 연산자(=, +=, -=, …)는 오른쪽 에서 왼쪽(<— )으로 연산된다.** 예를 들어 다음 연산식을 보자.

  ```java
  a = b = c = 5;
  ```

  - 위 연산식은 c = 5, b = c, a = b순서로 실행된다. 



##  3-3. 단항 연산자

- 단항 연산자는 피연산자가 단 하나뿐인 연산자를 말하며, 여기에는 **부호 연산자(+, -), 증감 연산자(++, - -) , 논리 부정 연산자(!), 비트 반전 연산자(~)가 있다.**

### 	3-3-1. 부호 연산자(+, -)

- 부호 연산자는 양수 및 음수를 표시하는 +, - 를 말한다. boolean 타입과 char 타입을 제외한 나머지 기본 타입에 사용할 수 있다. 

- 부호 연산자를 사용할 때 주의할 점은 **부호 연산자의 산출 타입은 int 타입이 된다**는 것이다. 예를 들어 short 타입 값을 부호 연산하면 int 타입 값으로 바뀐다. 그래서 다음 코드는 컴파일 에러가 발생한다.

  ```java
  short s = 100;
  short result = -s;  //컴파일 에러
  ```

  - 위의 코드는 다음과 같이 변경되어야 한다.

    ```java
    short s = 100;
    int result3 = -s;
    ```

### 3-3-2. 증감 연산자(++, - -)

- 증감 연산자는 변수의 값을 1증가(++) 시키거나 1감소(- -)시키는 연산자를 말한다.

- **boolean 타입을 제외한 모든 기본 타입의 피연산자에 사용할 수 있다.** 

- 연산식에서 증감 연산자만 있는 경우에는 증감 연산자가 변수 앞 또는 뒤 어디든 위치해도 상관없다.

  ```java
  ++i; or i++;  //모두 i=i+1; 로 동일
  --i or i--;   //모두 i=i-1; 로 동일
  ```



### 3-3-3. 논리 부정 연산자( ! )

- 논리 부정 연산자는 true를 false로, false를 true로 변경하기 때문에 **boolean 타입에만 사용**할 수 있다. 
- 논리 부정 연산자는 조건문과 제어문에서 사용되어 조건식의 값을 부정하도록 해서 실행 흐름을 제어할 때 주로 사용된다. 또한 두 가지 상태(true/false)를 번갈아가며 변경하는 토글(toggle) 기능을 구현할 때도 주로 사용한다. 



### 3-3-4. 비트 반전 연산자( ~ )

- 비트 반전 연산자는 정수 타입(byte, short, int, long)의 피연산자에만 사용되며, **피연산자를 2진수로 표현했을 때 비트값인 0을 1로, 1은 0으로 반전한다.** 연산 후, **부호 비트인 최상위 비트를 포함해서 모든 비트가 반전되기 때문에, 부호가 반대인 새로운 값이 산출된다.**

- 비트 반전 연산자를 사용할 때 주의할 점은 비트 반전 연산자 산출 타입은 int 타입이 된다는 것이다. 피연산자는 연산을 수행하기 전에 int 타입으로 변환되고, 비트 반전이 일어난다. 그래서 다음 코드는 컴파일 에러가 발생한다.

  ```java
  byte v1 = 10;
  byte v2 = ~v1;  //컴파일 에러
  ```

  - 그렇기 때문에 다음과 같이 변경되어야 한다.

    ```java
    byte v1 = 10;
    int v2 = ~v1;
    ```

- 비트 반전 연산자의 결과를 이용하면 부호가 반대인 정수를 구할 수도 있다. 물론 간단하게 부호 연산자인 - 를 이용해도 되겠지만, **비트 반전 연산자의 산출값에 1을 더하기하면 부호가 반대인 정수를 얻을 수 있다.** 예를 들어, 10을 비트 반전하면 -11 을 얻는데, 여기에 1을 더하면 -10 을 얻는다.

  ```java
  byte v1 = 10;
  int v2 = ~v1 + 1;  //-10이 v2에 저장
  ```

  

- 자바는 정수값을 총 32비트의 **이진 문자열로 리턴하는 Integer.toBinaryString() 메소드를 제공**한다.

  ```java
  String v1BinaryString = Integer.toBinaryString(10);
  ```

  - Integer.toBinaryString()메소드는 앞의 비트가 모두 0이면 0은 생략되고 나머지 문자열만 리턴하기 때문에 총 32개의 문자열을 모두 얻기 위해서는 다음과 같은 메소드가 필요하다. 리턴하는 str의 문자 수를 조사해서 32보다 작으면 앞에 0을 붙이도록 한 것이다.



## 3-4. 이항 연산자

- 이항 연산자는 피연산자가 두 개인 연산자를 말하며 여기에는 산술 연산자(+, -, *, /, %), 문자열 연결 연산자(+), 대입 연산자, 비교 연산자, 논리 연산자, 비트 논리 연산자, 비트 이동 연산자 등이 있다.



### 3-4-1. 산술 연산자(+, -, *, /, %)

- 우리가 일반적으로 말하는 사칙연산인 더하기(+), 빼기(-), 곱하기(*), 나누기(/)와 나머지를 구하는 연산자(%)를 포함해서 산술 연산자는 총 5개이다. 이 산술 연산자는 boolean 타입을 제외한 모든 기본 타입에 사용할 수 있다. 
- 주의할 점은 곱셈의 경우 연산자가 x가 아니라 *를 사용하고 나눗셈의 경우 / 를 사용한다. % 연산자가 조금 생소할 지도 모르겠지만, % 연산자는 나눗셈을 수행하고, 몫이 아닌 나머지를 돌려주는 연산자이다. 
- 산술 연산자의 특징은 피연산자들의 타입이 동일하지 않을 경우 다음과 같은 규칙을 사용해서 피연산자들의 타입을 일치시킨 후 연산을 수행한다. 
  1. 피연산자들이 모두 정수 타입이고, int 타입(4byte) 보다 크기가 작은 타입일 경우 모두 int 타입으로 변환 후, 연산을 수행한다. **따라서 연산의 산출 타입은 int이다.** 
  2. 피연산자들이 모두 정수 타입이고, long 타입이 있을 경우 모두 long 타입으로 변환 후, 연산을 수행한다. 따라서 **연산의 산출 타입은 long 이다.**
  3. 피연산자 중 실수 타입(float 타입, double 타입)이 있을 경우, 크기가 큰 실수 타입으로 변환 후, 연산을 수행 한다. 따라서 **연산의 산출 타입은 실수 타입이다.**

- **간단하게 정리하면 long을 제외한 정수 타입 연산은 int 타입으로 산출되고, 피연산자 중 하나라도 실수 타입이면 실수 타입으로 산출된다.** 위 내용을 따른다면 다음 코드는 컴파일 에러가 발생한다.

  ```java
  byte byte1 = 1;
  byte byte2 = 1;
  byte byte3 = byte1 + byte2; // 컴파일 에러
  ```

  - 위 코드를 에러가 나지 않도록 수정하려면

    ```java
    byte byte1 = 1;
    byte byte2 = 1;
    int result = byte1 + byte2;
    ```

- **정수 타입 연산의 결과가 int 타입으로 나오는 이유는 자바 가상 기계(JVM)가 기본적으로 32비트 단위로 계산하기 때문**이다. 다른 예를 들어보자, 다음 코드에서 result2와 result3에 저장되는 값은 무엇일까?

  ```java
  int int1 = 10;
  int int2 = 4;
  int result2 = int1 / int2;
  double result3 = int1 / int2;
  ```

  - result2에는 2가 저장된다. result3은 double 타입 변수이므로 2.5가 저장될까? 아니다. 연산 후의 결과가 2이므로 2를 실수화해서 2.0이 저장된다. 만약 2.5를 산출 결과로 얻고 싶다면 피연산자 중 최소한 하나는 실수 타입이어야 한다. 따라서 다음과 같이 1.0을 곱하여 실수 타입으로 만든 후 산술 연산을 하거나 int1과 int2 중 하나를 double 타입으로 강제 타입 변환한 후 산술 연산을 하면 된다.

    ```java
    double result3 = (int1*i.0) / int2;
    double result3 = (double)int1 / int2;
    double result3 = int1 / (double)int2;
    ```

- char 타입도 정수 타입이므로 산술 연산이 가능하다. 주의할 점은 char 타입이 산술 연산이 될 경우 int 타입으로 변환되므로 산출 타입은 int 타입이다. 따라서 다음 예제는 컴파일 에러가 발생한다. 

  ```java
  char c1 = 'A' + 1;     //c1 = B
  char c2 = 'A';         //c2 = A
  char c3 = c2 + 1;  //컴파일 에러.
  ```

  - 마지막 c3 는 다음과 같이 강제 타입 변환을 해서 char 타입으로 얻어야 한다.

    ```java
    char c3 = (char)(c2+1);
    ```

- 산술 연산은 어렵지 않게 이해할 수 있으나, 몇 가지 주의해야 할 점이 있다. 올바른 계산을 위해 값을 미리 검정해야 하고, 정확한 계산을 위해 실수 타입을 피해야 하며, 특수값 처리에 신경써야 한다. 



#### 오버플로우 탐지

- 산술 연산을 할 때 주의할 점은 연산 후의 산출값이 산출 타입으로 충분히 표현 가능한지 살펴봐야 한다. 산출 타입으로 표현할 수 없는 값이 산출되었을 경우, 오버플로우가 발생하고 쓰레기값(엉뚱한 값)을 얻을 수 있기 때문이다.

#### 정확한 계산은 정수 사용

- 정확하게 계산해야 할 때는 부동소수점(실수) 타입을 사용하지 않는 것이 좋다. 

  ```java
  public class AccuracyExample1 {
    public static void main(String[] args) {
      int apple = 1;
      double pieceUnit = 0.1;
      int number = 7;
  
      double result = apple - number*pieceUnit;
  
      System.out.println("사과 한개에서 ");
      System.out.println("0.7조각을 빼면, ");
      System.out.println(result + "조각이 남는다. ");
    }
  }
  
  
  //출력 결과
  //사과 한개에서
  //0.7 조각을 빼면, 
  //0.29999999999조각이 남는다.
  ```

  - 출력 결과가 정확하게 나오지 않는 이유는, 이진 포맷의 가수를 사용하는 **부동소수점 타입(float, double)은 0.1을 정확히 표현할 수 없어 근사치로 처리하기 때문**이다.
  - 정확한 계산이 필요하다면 정수 연산으로 변경하여 계산해야 한다. 

  ```java
  public class AccuracyExample2 {
    public static void main(String[] args) {
      int apple = 1;
  
      int totalPiece = apple * 10;
      int number = 7;
      int temp = totalPiece - number;
  
      double result = temp/10.0;
  
      System.out.println("사과 한개에서 ");
      System.out.println("0.7 조각을 빼면, ");
      System.out.println(result + "조각이 남는다. ");
    }
  }
  ```

  

#### NaN(Not a Number)과 Infinity 연산

- / 또는 % 연산자를 사용할 때도 주의할 점이 있다. 좌측 피연산자가 정수 타입인 경우 나누는 수인 우측 피연산자는 0을 사용할 수 없다. 만일 0으로 나누면 컴파일은 정상적으로 되지만, 실행 시 ArithmeticException(예외)가 발생한다.

  ```java
  5 / 0 --> ArithmeticException 예외 발생
  5 % 0 --> ArithmeticException 예외 발생
  ```

  - 자바는 프로그램 실행 도중 예외가 발생하면 실행이 즉시 멈추고 프로그램은 종료된다. ArithmeticException이 발생했을 경우 프로그램이 종료되지 않도록 하려면 예외 처리를 해야 한다. 예외 처리는 예외가 발생되었을 경우, catch 블록을 실행하도록 하는 것이다.

    ```java
    try{
      //int z = x / y;
      int z = x % y;
      System.out.println("z: " + z);
    }catch(ArithmeticException e){
      System.out.println("0으로 나누면 안됨");
    }
    ```

  - 그러나 실수 타입인 0.0 또는 0.0f로 나누면 ArithmeticException이 발생하지 않고, / 연산의 결과는 Infinity(무한대) 값을 가지며, %연산의 결과는 NaN(Not a Number)을 가진다.

    ```java
    5 / 0.0 --> Infinity
    5 % 0.0 --> NaN
    ```

    - 주의할 점은 /와 % 연산의 결과가 Infinity 또는NaN이 나오면 다음 연산을 수행해서는 안 된다. 왜냐하면 이 값과 산술 연산을 하면 어떤 수와 연산하더라도 Infinity 와 NaN이 산출되어 데이터가 엉망이 될 수 있다.

      ```java
      Infinity + 2 --> Infinity
      NaN + 2 --> NaN
      ```

  - 프로그램 코드에서 /와 % 연산의 결과가 Infinity 또는 NaN인지 확인하려면 Double.isInfinity()와 Double.isNaN() 메소드를 이용하면 된다. 이 메소드들은 double 타입의 값을 매개값으로 받아서 이 값이 Infinity 또는 NaN 이라면 true를 리턴하고, 그렇지 않다면 false를 리턴한다. 

#### 입력값의 NaN 검사

- 부동소수점(실수)을 입력받을 때는 반드시 NaN검사를 해야 한다. 다음 예제를 보자. 3라인에서 부동소수점으로 변환이 가능한 문자열을 입력받는다고 가정해보자. 악의성 있는 사용자는 숫자로 변환이 안 되는 "NaN"을 입력할 수도 있다.

  ```java
  public class InputdataCheckNaNexample{
    public static void main(String[] args){
      String userInput = "NaN";
      double val = Double.valueOf(userInput);
      
      double currnentBalance = 10000.0;
      
      currentBalance += val;
      System.out.println(currentBalance);
    }
  }
  ```

  

- "NaN" 문자열은 Double.valueOf() 메소드에 의해 double 타입으로 변환되면 NaN이 된다. 따라서 val에는 NaN이 저장된다. 문제는 NaN은 산술 연산이 가능하다는 점이다. NaN과 어떠한 수가 연산되면 결과는 NaN이 산출되어 데이터가 엉망이 된다. 

- 6라인에서 currentBalance에 10000.0을 저장하고 8라인에서 NaN과 더하기 연산을 수행하면 currentBalance는 NaN이 저장되어 원래 데이터가 없어져 버린다. 

- 그렇기 때문에 사용자로부터 문자열을 입력받을 때에는 반드시 "NaN"인지를 조사하고 만약 "NaN"이라면 NaN과 산술 연산을 수행해서는 안된다.  위의 예제를 수정하면 다음과 같다.

  ```java
  public class InputdataCheckNaNExample2{
    public static void main(String[] args){
      String userInput = "NaN";
      double val = Double.valueOf(userInput);
      
      double currentBalance = 10000.0;
      
      if(Double.isNaN(val)){
        System.out.println("NaN이 입력되어 처리할 수 없음.");
        val = 0.0;
      }
      
      currentBalance += val;
      System.out.println(currentBalance);
    }
  }
  ```

  - 8라인의 if 조건식에서는 Double.NaN() 메소드를 이용해서 변수 val의 값이 NaN인지를 검사한다. 주의할 점은 NaN인지를 조사를 할 때 == 연산자를 사용하면 안 된다. **NaN은 != 연산자를 제외한 모든 비교 연산자를 사용할 경우 false 값을 리턴하기 때문이다.** NaN인지 검사를 하려면 반드시 Double.isNaN()을 사용해야 한다.
  - **Double.isNaN()메소드는 매개값이 NaN이라면 true를 리턴한다.** if 조건식이 true가 되면 9~10라인이 실행되고, 변수 val은 NaN대신 0.0이 된다. 그래서 13라인에서 currentBalance 값과 0.0이 연산되어 currentBalance는 원래 값을 유지하게 된다.



### 3-4-2. 문자열 연결 연산자(+)

- **문자열 연결 연산자인 +는 문자열을 서로 결합하는 연산자이다.** + 연산자는 산술 연산자, 부호 연산자인 동시에 문자열 연결 연산자이기도 하다. **피연산자 중 한쪽이 문자열이면 + 연산자는 문자열 연결 연산자로 사용되어 다른 피연산자를 문자열로 변환하고 서로 결합한다.** 

  ``` java
  String str1 = "JDK" + 6.0;    //-> JDK6.0
  String str2 = str1 + " 특징";  //-> JDK6.0 특징
  ```

- 간혹 + 연산자가 산술 연산자인지 문자열 연결 연산자인지 판단하기 어려운 경우가 있다. 

  ```java
  String str1 = "JDK" + 3 + 3.0;   //->JDK33.0
  ```

  ```java
  String str2 = 3 + 3.0 + "JDK";  //->6.0JDK
  ```

### 3-4-3. 비교 연산자(<, <=, >, >=, ==, !=)

- 비교 연산자는 대소(<, <=, >, >=) 또는 동등(==, !=)을 비교해서 boolean 타입인 true/false를 산출한다.

- 대소 연산자는 boolean 타입을 제외한 기본 타입에 사용할 수 있고, 동등 연산자는 모든 타입에 사용될 수 있다. 

- 비교 연산자는 흐름 제어문인 조건문(if), 반복문(for, while)에서 주로 이용되어 실행 흐름을 제어할 때 사용된다.

- 만약 피연산자가 char 타입이면 유니코드 값으로 비교 연산을 수행한다. 

  ```java
  ('A' < 'B')  --> (65 < 66)
  ```

- 비교 연산자에서도 연산을 수행하기 전에 타입 변환을 통해 피연산자의 타입을 일치시킨다.

  ```java
  'A' == 65;  --> true
  3 == 3.0  --> true
  ```

  

- 그러나 한 가지 예외가 있는데, 0.1 == 0.1f 와 같은 경우를 보자. 정상적이라면 0.1f가 좌측 피연산자의 타입인 double로 변환되어 0.1 == 0.1이 되고 true가 산출되어야 하지만, 이 결과값은 false가 산출된다.

  ```java
  0.1 == 0.1f  -->false
  ```

  - 그 이유는 이진 포맷의 가수를 사용하는 모든 부동소수점 타입은 0.1을 정확히 표현할 수가 없어서 0.1f는 0.1의 근사값으로 표현되어 0.10000000149011612와 같은 값이 되기 때문에 0.1보다 큰 값이 되어 버린다. 
  - 해결책은 다음 예제와 같이 피연산자를 모두 float타입으로 강제 타입 변환한 후에 비교 연산을 하든지, 정수로 변환해서 비교하면 된다.

- String 타입의 문자열을 비교할 때에는 대소(<, <=, >, >=)연산자를 사용할 수 없고, 동등(==, !=) 비교 연산자는 사용할 수 있으나 문자열이 같은지, 다른지를 비교하는 용도로는 사용되지 않는다. 참조 타입인 String  변수를 비교할 때 == 연산자를 사용하면 원하지 않는 결과가 나올 수도 있다. 

  ```java
  String strVar1 = "신용권";
  String strVar2 = "신용권";
  String strvar3 = new String("신용권");
  ```

  - 자바는 문자열 리터럴이 동일하다면 동일한 String 객체를 참조하도록 되어 있다. 그래서 변수 strVar1과 strVar3 는 동일한 String 객체의 번지값을 가지고 있다.
  - 그러나 변수 strVar3는 객체 생성 연산자인 new로 생성한 새로운 String 객체의 번지값을 가지고 있다.

  ```java
  strVar1 == strVar2  --> true
  strVar2 == strVar3  --> false
  ```




<br>

### 3-4-4. 논리 연산자 (&&, ||, &, |, ^, !)

- 논리 연산자는 논리곱(&&), 논리합(||), 배타적 논리합(^) 그리고 논리 부정(!) 연산을 수행한다.

- 논리 연산자의 피연산자는 boolean타입만 사용할 수 있다.

  ![image](https://user-images.githubusercontent.com/52916061/76201996-7c847400-6237-11ea-97bc-cca0e6d16dd3.png)
  - &&와 &는 산출 결과는 같지만 연산 과정이 조금 다르다.
    - &&는 앞의 피연산자가 false라면 뒤의 피연산자를 평가하지 않고 바로 false라는 산출 결과를 낸다. 왜냐하면 하나라도 false이면 전체 연산식이 false가 되기 때문이다.
    - &는 두 피연산자 모두를 평가해서 산출 결과를 낸다. 
    - **따라서 &보다 &&가 더 효율적으로 동작한다.**
  - ||와 |도 마찬가지이다.
    - ||는 앞의 피연산자가 true라면 뒤의 피연산자를 평가하지 않고 바로 true라는 산출 결과를 낸다. 왜냐하면 하나라도 true이면 전체 연산식은 true이기 때문이다. 
    - |는 두 피연산자 모두를 평가해서 산출 결과를 낸다.
    - **따라서 |보다 ||가 더 효율적으로 동작한다.**



<br>

### 3-4-5. 비트 연산자(&, |, ^, ~, <<, >>, >>>)

- 비트 연산자는 데이터를 비트(bit) 단위로 연산한다. 즉 0과 1이 피연산자가 된다. 그렇기 때문에 0과 1로 표현이 가능한 정수 타입만 비트 연산을 할 수 있다.
- **실수 타입인 float와 double은 비트 연산을 할 수 없다.** 
- 비트 연산자는 기능에 따라 비트 논리 연산자(&, |, ^, ~)와 비트 이동 연산자(<<. >>, >>>)로 구분한다. 
- 일반 논리 연산자가 true와 false를 연산한다면 비트 논리 연산자는 0과 1을 연산한다. 
- **비트 이동 연산자는 비트를 좌측 또는 우측으로 이동하는 연산자이다.** 



<br>

#### 비트 논리 연산자(&, |, ^)

- 비트 논리 연산자에는 &, |, ^, ~가 있다. 

- &, |, ^연산자는 피연산자가 boolean 타입일 경우에는 일반 논리 연산자이고, **피연산자가 정수 타입일 경우에는 비트 논리 연산자로 사용**된다.

  ![image](https://user-images.githubusercontent.com/52916061/76206085-bd33bb80-623e-11ea-96d1-b0e2280d690f.png)

- 비트 연산자는 피연산자를 int 타입으로 자동 타입 변환한 후 연산을 수행한다. 

- 그렇기 때문에 byte, short, char 타입을 비트 논리 연산하면 그 **결과는 int 타입**이 된다. 

  ```java
  byte num1 = 45;
  byte num2 = 25;
  byte result = num1 & num2; //컴파일 에러
  int result = num1 & num2;
  ```



#### 비트 이동 연산자 ( <<, >>, >>>)

- 비트 이동(shift) 연산자는 정수 데이터의 비트를 좌측 또는 우측으로 밀어서 이동시키는 연산을 수행한다. 

  ![image](https://user-images.githubusercontent.com/52916061/76207429-21577f00-6241-11ea-9e70-a9ed678758a2.png)

  

<br>

### 3-4-6. 대입 연산자(=, +=, -=, *=, /=, %=, ^=, |=, <<=, >>=, >>>=)

- 대입 연산자는 오른쪽 피연산자의 값을 좌측 피연산자인 변수에 저장한다. 

- 오른쪽 피연산자는 리터럴 및 변수, 그리고 다른 연산식이 올 수 있다. 

- 단순히 오른쪽 피연산자의 값을 변수에 저장하는 단순 대입 연산자가 있고, 정해진 연산을 수행한 후 결과를 변수에 저장하는 복합 대입 연산자도 있다. 

  ![image](https://user-images.githubusercontent.com/52916061/76208092-5c0de700-6242-11ea-8755-04afedcd3e4b.png)

- 대입 연산자는 모든 연산자들 중에서 가장 낮은 연산 순위를 가지고 있기 때문에 제일 마지막에 수행된다.



<br>

## 3-5. 삼항 연산자

- 삼항 연산자( ? : )는 세 개의 피연산자를 필요로 하는 연산자를 말한다. 

- **삼항 연산자는 ? 앞의 조건식에 따라 콜론 : 앞뒤의 피연산자가 선택된다고 해서 조건 연산식이라고 부르기도 한다.**

  ![image](https://user-images.githubusercontent.com/52916061/76209611-99c03f00-6245-11ea-8531-eea39e334a06.png)

- 조건식을 연산하여 truer가 나오면 삼항 연산자의 결과는 피연산자2가 된다. 반면에 조건식을 연산하여 false가 나오면 삼항 연산자의 결과는 피연산자3이 된다. 
  - 피연산자2와 3에는 주로 값이 오지만, 경우에 따라서는 연산식이 올 수도 있다. 









































